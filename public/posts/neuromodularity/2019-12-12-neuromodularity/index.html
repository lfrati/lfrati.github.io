<!doctype html>
<html
  lang="en-us"
  dir="ltr"
>
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width" />
<link
  href="https://fonts.googleapis.com/css2?family=Mulish:wght@200;300;400;500;600;700;800;900&display=swap"
  rel="stylesheet"
/>






<link
  rel="icon"
  type="image/svg+xml"
  href="/favicon/favicon.svg"
  media="(prefers-color-scheme: light)"
/>
<link
  rel="icon"
  type="image/svg+xml"
  href="/favicon-dark/favicon.svg"
  media="(prefers-color-scheme: dark)"
/>

<link
  rel="icon"
  type="image/png"
  href="/favicon/favicon-96x96.png"
  sizes="96x96"
  media="(prefers-color-scheme: light)"
/>
<link
  rel="icon"
  type="image/png"
  href="/favicon-dark/favicon-96x96.png"
  sizes="96x96"
  media="(prefers-color-scheme: dark)"
/>

<link
  rel="icon"
  type="image/x-icon"
  href="/favicon/favicon.ico"
  media="(prefers-color-scheme: light)"
/>
<link
  rel="icon"
  type="image/x-icon"
  href="/favicon-dark/favicon.ico"
  media="(prefers-color-scheme: dark)"
/>
<title>
  
    A peek into Neuromodularity | while(True):
  
</title>

  <link rel="stylesheet" href="/css/bundle.css" />



  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath: [['\\(', '\\)']]                  
    },
    loader:{
      load: ['ui/safe']
    },
  };
</script>



  </head>
  <body>
    <header>
      <nav class="navbar">
  <div class="glider-container">
    <div class="glider">
      <div class="cell"></div>
      <div class="cell"></div>
      <div class="cell"></div>
      <div class="cell"></div>
      <div class="cell"></div>
      <div class="cell"></div>
      <div class="cell"></div>
      <div class="cell"></div>
      <div class="cell"></div>
    </div>
  </div>
  <h1 class="site-title">
    <a href="http://localhost:1313/" class="site-title-link">while(<span class="true">True</span>):</a>
  </h1>
  <div class="spacer"></div>
  <ul>
      <li>
        <a
          href="/"
          class="brackets "
          
        >
          Home
        </a>
      </li>
      <li>
        <a
          href="/about/"
          class="brackets "
          
        >
          About
        </a>
      </li>
  </ul>
</nav>

    </header>
    <main class="main">
      
  
  

  <article class="post">

    <header class="post-header">
      <h1 class="post-title">A peek into Neuromodularity</h1>
      <time datetime="2019-11-12T00:00:00&#43;00:00">November 12, 2019</time>
    </header>

    <div class="post-content">
    <p>{% raw %}</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>{% endraw %}</p>
<p><em>Warning: All sketches in this page are running on your machine, may the gods of computing bestow their blessing upon you.</em></p>
<h1 id="geometric-graphs">
  <a href="#geometric-graphs" class="heading-anchor" aria-hidden="true" style="text-decoration: none; color: #999;">#</a>
  Geometric graphs
</h1>
<p>When working with networks it is common to assume that edge properties and node properties are somewhat independent. Nodes often contain information about the entity they represent and edges describe the relationships between those entities. However in practice it is often the case that nodes may be embedded in some space of interested. Let us consider the case where nodes represent cities and edges are the roads between them. It is intuitive to assume that each node (i.e. city) is associated with some coordinates. Given the coordinates of a node it is natural to assume that each link (i.e. road) has a certain length that might not be explicitly listed among the properties of those edges.</p>
<p>These extra pieces of information are introduced by the space in which the nodes are embedded thanks to some <strong>distance metric</strong> (e.g. Euclidean distance) defined on it.
When this extra information is available we can employ it to enrich the mechanism that shape our networks. For example, we can make the rule that nodes are only able to make connections within a certain &ldquo;range&rdquo; defined by that distance like in the sketch below.</p>
<p>{% raw %}</p>
<!-- raw HTML omitted -->
<p>This approach is called <a href="https://en.wikipedia.org/wiki/Random_geometric_graph">Geometric Random Graph</a>. In this type of network the connectivity is controlled by a radius parameter, such that each node wires with all the nodes within that radius. Below you can see how the number of links and connected components vary as the radius parameter changes. The network starts off with no edges but as the connection radius increase the number of connected components quickly converges to a single giant component. We are employing a hard threshold (i.e. connections are made with every node within the range, and no nodes outside the range) for simplicity for now but other alternatives exist, where connections are made probabilistically and closer nodes have higher probabilities (i.e. Gaussian probability decay as distance increases), which we are going to use later on.</p>
<p>{% raw %}</p>
<!-- raw HTML omitted -->
<h1 id="complex-contagion">
  <a href="#complex-contagion" class="heading-anchor" aria-hidden="true" style="text-decoration: none; color: #999;">#</a>
  Complex contagion
</h1>
<p>It is easy to draw a parallel between the geometric graphs we have been talking about and systems composed of many spatially embedded nodes such as the <strong>neurons</strong> in a brain. In the same way infectious individuals spread from a city to city, activity spikes are transmitted from neuron to neuron. However, neural networks provide even richer dynamics than those already complex one of infection spreading. Neurons can interact with each other in complex non-linear ways, a behaviour called <strong>complex contagion</strong>. In social networks this behaviour is particularly common. As we can imagine, when interacting with other people an idea that reaches us from many different directions is much more effective. We can try to approximate this scenario in the following way:</p>
<ul>
<li>Neurons fire when the incoming impulses surpass a certain <strong>threshold</strong>.</li>
<li>Incoming impulses add up, but constantly <strong>decay</strong> (i.e. multiple simultaneous inputs are much more effective than multiple single ones).</li>
<li>Each time a neuron fires the threshold for firing is raised.</li>
</ul>
<p>{% raw %}</p>
<!-- raw HTML omitted -->
<h1 id="complex-spreading-dynamics">
  <a href="#complex-spreading-dynamics" class="heading-anchor" aria-hidden="true" style="text-decoration: none; color: #999;">#</a>
  Complex spreading dynamics
</h1>
<p>When these mechanisms (geometric embedding and complex contagion) are combined the results quickly increase in complexity. In the following sketch we can see them at work. A network that describes a collection of neurons has been generated using the rules we have introduced. Using the mouse wheel or clicking we can now excite one of the neurons to make it send actvity spikes to its neighbours. When a lot of impulses are travelling along an edge the thickness increases and the color changes to red. Neurons&rsquo; color also turn to red the closer they get to firing. As neurons start firing their size increases along with the thin grey circle around them that represents the spiking threshold.</p>
<p>Feel free to experiment exciting different neurons and see how the activity spreads through the network. To keep the overall activity under control the amount of impulses that can be present at any given time is capped. Also, since the threshold for spiking increases as the neurons keep spiking we can see that increasing the connectivity of the network the neurons will blow up incredibly before starting to deflate.</p>
<p>{% raw %}</p>
<!-- raw HTML omitted -->
<h1 id="reservoir-computing">
  <a href="#reservoir-computing" class="heading-anchor" aria-hidden="true" style="text-decoration: none; color: #999;">#</a>
  Reservoir Computing
</h1>
<p>The topics we have introduced and discussed so far are particularly relevant for a specific branch of Machine Learning known as Reservoir Computing. Traditional Neural Networks (artificial or biological) employ deep stacks of neurons that process input signals in a feed-forward fashion.
These deep neural networks have achieved outstanding results in recent years. However optimising the deep stack of layers that form modern neural networks architectures can be challenging and they require specialised structures to process complex temporal signals. These problems can be lessened by employing a <strong>Neural Reservoir</strong>, a randomly initialized sub-network with recurrent connection (i.e. connections feeding back into the reservoir).
This neural reservoir is then connected to two smaller layers, one that sits between the inputs and the reservoir, and one that receives signals from the reservoir and passes them to the output.</p>
<p>You can see a schematic version of this architecture in the following sketch. On the left the white/black squares represents input units. The signals from those units are fed into the neural reservoir represented by the random geometric graph in the middle. The signals propagate through the neural reservoir before being read by the green output units on the right. The signals received by output units are graphed under the network in an ECG style.
{% raw %}</p>
<!-- raw HTML omitted -->
<p>All that would be left to complete the hypothetical training scenario would be to add mechanism to train the input/output connections. Obviously the sketch above is just meant to give a general understanding of the setup. In practice there are various considerations to be made and different choice lead to different implementations.</p>
<p>The main difference of our little sketch with actual models is probably the fact that signals spread at a constant speed (where speed is introduced because we have an Euclidean distance between nodes, and hence we can talk about something like meters per second). Often the connections between nodes are represented as &ldquo;just&rdquo; adjacency matrices or, if chasing a better biological plausibility, as a 3D <strong>lattice</strong>.
We are going to employ a similar approach to keep a notion of space while avoiding the full additional complexity of unrestricted space. Our nodes are going to be arranged in a 2D lattice so that nodes have a notion of spatial neighbours.</p>
<h1 id="the-dangers-of-time">
  <a href="#the-dangers-of-time" class="heading-anchor" aria-hidden="true" style="text-decoration: none; color: #999;">#</a>
  The dangers of time
</h1>
<p>As we approach the end of our introduction we are going to spend a few words about our handling of time in our simulations. Despite the appeal of using continuous time there are some caveats to be considered. If we seed the network by forcing one node to spike and start sending signals to its neighbours we have to consider that some of those signals might arrive before others. While apparently innocuous this detail can quickly set our machines on fire. That is because the number of events we need to keep track increases <strong>exponentially</strong>, as every node spiking will likely generate more than one signals.</p>
<p>This problem can be counteracted either by using some careful wiring and appropriate activation thresholds or by removing the notion of time entirely. If we chose the latter every signal travelling on an edge leaves and arrives at the same time as everyone else&rsquo;s which means the number of concurrent events to track per time step is now bounded by the number of edges in the network. In the following sketch we can get a feeling for the dangers of time on lattice networks with a few random connections (the difference between constant speed and constant crossing time is more visible on longer edges).</p>
<p>On the left we have a version of our network where edges are crossed at a constant speed based on the distance between the endpoints. On the right instead we have the same network but the time to cross an edge is constant no matter it&rsquo;s length. You can select a node on the left and it&rsquo;s counterpart on the right (both highlighted in yellow) and click to start releasing signals. The more signals are sent the faster the symmetry between the two versions will be broken. If enough signals are sent the time-based version will probably start blowing up (signals are capped at 1000 for your own safety), while the time-less counterpart will probably settle on a steady activation level.
{% raw %}</p>
<!-- raw HTML omitted -->
<h1 id="spiky-lattices">
  <a href="#spiky-lattices" class="heading-anchor" aria-hidden="true" style="text-decoration: none; color: #999;">#</a>
  Spiky lattices
</h1>
<p>We have discussed the role of space and time in growing our geometric networks so we can now state a bit more clearly what our intent is. Recent works on neural reservoirs have highlighted the relevance of modularity in forming useful reservoirs that can provide long lasting signals to learn from. It is especially apparent in the case where the reservoir uses hard thresholds as their source of non-linearity, and the resulting dynamic is very close to that of <strong>complex contagion</strong>, the relevance of having highly connected modules.
In that scenario producing and sustaining spikes requires multiple simultaneous signals that have to come at just the right time. A tightly connected component can provide the push needed to cross those thresholds. Why not have a fully connected graph then? If all the nodes spike all the time then the information present in those spikes is almost none and hence the reservoir is unsuitable for learning. We are not going to perform learning in our experiments. We are going instead to focus our attention on the role of modularity and mechanisms that lead to its formation.</p>
<p>In the following last sketch we show a simple scenario using a lattice network with local connections and low activation threshold of 3. Nodes are connects randomly with a local preference that scales linearly with distance. Use the slider to change the level of connectivity in the system. Use the mouse to send signals from certain nodes or use the button &ldquo;spark&rdquo; to send one signal from every node at the same time. The activity bar shows the number of nodes that are currently spiking (i.e. green for none, red for all) As you change the level of connectivity of the network you can observe that activity can either <em>saturate</em> (i.e. almost all nodes fire all the time) or <em>vanish</em> (i.e. the signals are not sufficient to cross the thresholds)</p>
<p>{% raw %}</p>
<!-- raw HTML omitted -->
<h1 id="optimal-modularity">
  <a href="#optimal-modularity" class="heading-anchor" aria-hidden="true" style="text-decoration: none; color: #999;">#</a>
  Optimal modularity
</h1>
<p>We are now reaching the end of this whirlwind tour of neural reservoirs and geometric networks. The last piece we want to present is a recent result in &ldquo;<em>Optimal modularity and memory capacity of neural reservoirs</em>&rdquo; (Rodriguez et al.). In their work the authors show that in neural reservoirs an optimal balance between community formation and global connections can be found, so that the resulting reservoir maximise the learning capability of the systems it is used in. The experiments we are going to focus our attention on involve a <strong>parameter μ</strong> that balances the ratio of local (i.e. within a community) vs global (i.e. between communities) connections.</p>
<ul>
<li>
<p>When μ = 0 the connections are entirely local, which means that every node is connecting only to other nodes in the same community (defined a priori) → Maximal modularity.</p>
</li>
<li>
<p>When μ = 0.5 half of the connection of each node are made with nodes in the same community and half with nodes from the other communities → Minimal modularity.</p>
</li>
</ul>
<p>As μ varies between 0 and 0.5 we can observe different behaviours of the system then we excite some neurons in response to an hypothetical outside stimulus. For values near 0 the communities are very strongly wired and are able to easily overcome the activation threshold needed for sustained spiking but the signal remains confined inside the community because of the lack of bridges to other communities. At the other end of the spectrum when μ approaches 0.5 the input signals are able to reach most neurons in the network but the signal quickly dies out because the connection are too <em>spread out</em> and unable to consistently reach the activation threshold.
Between these two extreme is possible to find a <strong>balance</strong> point where the local structure is sufficiently tight to sustain spiking over long periods of time, and the amount of global connections is sufficient to spread the signals to other communities.</p>
<p>Below you can see a sketch that shows a simplified version of the setup we just mentioned.
There are 9 communities of 16 nodes each that start initially fully wired within their local communities. As you increase the value of μ local connections are selected and random and turned into global connections by rewiring them to connect to a random node from another community. This process is repeated until the ratio of local/global connections equals μ. This process involves only rewiring so the overall number of connections remains the same, only the wiring structure is changed. The problem has been simplified by assuming that every connections is of equal unitary weight and that interactions are only excitatory. This obviously reduces the possible dynamics of the system but is still sufficient to see how different levels of modularity influence the outcomes.</p>
<p>{% raw %}</p>
<!-- raw HTML omitted -->
<h1 id="evolved-communities">
  <a href="#evolved-communities" class="heading-anchor" aria-hidden="true" style="text-decoration: none; color: #999;">#</a>
  Evolved communities
</h1>
<p>A natural question to ask is &ldquo;Can a similar optimal modularity be grown?&rdquo;. To test this possibility we have employed an evolutionary algorithm that has been optimizing a fitness function that explicitly rewards spreading between communities. During each epoch of our evolutionary training each of the communities in our network has been artificially spiked. This can be seen as receiving an input from outside, like would happen when a contiguous brain region receives sensory inputs.</p>
<p>The results have then been analysed using some standard modularity detection algorithms such as <strong>Louvain</strong>. As can be seen below such optimal modularity is almost entirely recovered and the networks evolve toward a μ measure of roughly 0.4, which is consistent with the results obtained in other studies. Some of the communities identified using the Louvain measure have been joined together but we can still identify the original block structure. In all experiments the center community can clearly distinguished from the other due to the specific setting used. As the only &ldquo;central&rdquo; community in close proximity to all other it can play a key role in facilitating the spread of information between distant communities.</p>
<p>{% raw %}</p>
<!-- raw HTML omitted -->
<h1 id="information-diffusion">
  <a href="#information-diffusion" class="heading-anchor" aria-hidden="true" style="text-decoration: none; color: #999;">#</a>
  Information Diffusion
</h1>
<p>How does the system coordinates itself as a whole while relying only on local interactions? And how much information must those signals carry? Our first attempt at modelling local interactions involves relying on the spiking levels of nodes. More specifically each node that spikes releases a &ldquo;virtual&rdquo; medium that carries information about the activity levels to other nodes in its <strong>Moore</strong> neighbourhood. Neighbouring nodes that receive this info from multiple source gather it to form an approximate, temporally delayed representation of the overall activity of the whole system.</p>
<p>Below we can see an example of this information spreading in a chemical looking fashion. The short clip shows, for each node in the network, the absolute difference between their local information and the actual activity level of the system. Darker colors represent nodes that have a good approximation of the global spiking levels. Brighter colors instead represent nodes that are lagging behind. We can see information fronts slowly diffuse throught the network as the local information is passed from node to node.</p>
<p>{% raw %}</p>
<!-- raw HTML omitted -->
<p>The algorithm we have tested to promote locality works as follows:</p>
<ul>
<li>If the node being optimised is <strong>spiking</strong>: the spiking information is used to locate nodes that are not spiking. This is done by multiplying it by the gaussian distribution used for edge formation so that close by nodes with low activity are more likely to be sampled.</li>
<li>If the node being optimised is <strong>not spiking</strong>: the spiking information is used to locate nodes that have been consistently spiking and an edge from that node to the current node is formed by rewiring one of the other outgoing connections from the current node.
This approach is aimed at simulating a simple setting where neurons that spike release &ldquo;chemical&rdquo; that favour the formation of new outgoing connections while neurons that don&rsquo;t reach the spiking threshold undergo a reverse process that stimulates forming new connections with them.</li>
</ul>
<p>Unfortunately this approach doesn&rsquo;t seem to lead to the emergence of modularity that we are looking for. Quite the contrary it seems that even when networks start from perfect modularity (μ = 0) the community structure is degraded rather than improved. To understand why this might be happening we can look at the first few iterations of our &ldquo;optimisation&rdquo; process. The network in questions is formed by 9 communities arranged in a 3x3 grid. During each episode every pre-determined module is artificially sparked in turn. Activity is left spreading for a number of iterations sufficient to allow for every community in the network to start spiking (or until the activity levels drop to zero).
As we can see below as simulation progress we can observe that the signals start reaching farther and father nodes (activity pane on the left shows more spread out activity patterns). The nodes able to spike become fewer and fewer (spiking pane on the right show spikes rapidly stopping, until each episode resembles a blip).</p>
<p>{% raw %}</p>
<!-- raw HTML omitted -->
<p>If we take a closer look at the network topology we can observe the effect of our local rules. Below you can see, on the left the initial perfectly modular structure, and on the right the results of several rounds of &ldquo;optimisation&rdquo;. We can notice that several nodes have a large number of incoming/outgoing connections. This happens because nodes that are selected as the best candidates for a specific nodes are likely to be the best candidates also for all it&rsquo;s neighbours. The diffusion mechanism has allowed nodes to access global information through local mechanisms but they lack the <strong>cooperation</strong> mechanisms needed to avoid <strong>over-exploiting</strong> that information.</p>
<p>{% raw %}</p>
<!-- raw HTML omitted -->
<h1 id="minimal-modularity">
  <a href="#minimal-modularity" class="heading-anchor" aria-hidden="true" style="text-decoration: none; color: #999;">#</a>
  Minimal modularity
</h1>
<p>How much connectivity is essential to ensure the signal from a community can spread to all the others? What kind of wiring is crucial to keep a community alive? If we consider the constraints imposed by the threshold function we use in our experiments we can calculate minimal conditions for survival. In particular we can identify two necessary components in our communities:</p>
<ul>
<li>a &ldquo;surviving&rdquo; fully connected sub-component capable of overcoming the threshold set</li>
<li>an &ldquo;activating&rdquo; set of edges that keep the rest of the community alive</li>
<li>a &ldquo;spreading&rdquo; set of connections that are able to propagate the signal to neighbouring communities.</li>
</ul>
<p>Once an activation threshold is determined then a minimal surviving <strong>clique</strong> is a set on <em>threshold + 1</em> fully-connected nodes. We can see an example of that in the image below, highlighted in red. In the image below we can see in blue the set of weights needed to keep the community alive. The remaining edges can then be used to spread the signal.</p>
<p>{% raw %}</p>
<!-- raw HTML omitted -->
<p>To minimally connect two communities we need to make spike every node in the kernel of the community we want to excite. Since the kernel contains <em>threshold+1</em> nodes and each of them needs to receive at least <em>threshold</em> signals for a total of <em>threshold x (threshold + 1)</em> edges. We can see this set up in the sketch below. Each community is connected to the next one forming a chain of communities that spans the whole network. The whole structure is resting on a precarious <strong>equilibrium</strong> since the network has barely enough signal to overcome the threshold barrier. We can see an example of this by using the &ldquo;sabotage&rdquo; button below. If enabled one single edge is removed from every center node of each community (the crippled node is shown in black). In this new regime the damaged kernel doesn&rsquo;t have enough activity to keep spiking so after propagating the signal the activity in the community dies out. This creates an interesting effect where the signal travels along the chain of communities like a propagating wave.</p>
<p>{% raw %}</p>
<!-- raw HTML omitted -->
<p>This seemingly secondary results is more interesting than expected. What we have obtained seeking the minimal possible wiring is a setup where each community is essentially a node of a network in &ldquo;<strong>community space</strong>&rdquo;. The nodes in this new space are supersets of the previous nodes where the &ldquo;complex contagion&rdquo; property has been assimilated into the activation function. Consider for example the case where activity is both excitatory and inhibitory, the previously simple threshold function that controls the activity in &ldquo;nodes space&rdquo; now becomes a much more complex stateful function in &ldquo;community space&rdquo;. This complexification mechanism can allow us to appreciate the emergence of complex behaviour in networks governed by simple activation functions. Especially so if we consider that the network itself can change over time as a function of its own activity.</p>
<p>{% raw %}</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>{% endraw %}</p>

    </div>

  </article>


    </main>
    <footer>
      <hr />
<div class="footer-content">
  <span>&copy 2023 - 2025 Lapo Frati</span>
  
    <a href="http://localhost:1313/index.xml" class="rss-link" title="RSS Feed">
      RSS Feed
      <img src="/RSS-icon.svg" alt="RSS" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" style="vertical-align: middle; margin-left: 6px;">
    </a>
  
</div>

    </footer>
    
      <script src="/js/main.js"></script>

  </body>
</html>
