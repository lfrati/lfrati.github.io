{{ define "main" }}

  <article class="about-page">

    <div class="about-content">
      <div class="profile-section">
        <div class="glitch-profile">
          <canvas id="glitch-profile"></canvas>
        </div>
      </div>
      
      <div class="post-content">
        {{ .Content }}
      </div>
    </div>

  </article>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    const canvas = document.getElementById('glitch-profile');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });

    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(-1,1,1,-1,0,1);

    const loader = new THREE.TextureLoader();
    const tex = await loader.loadAsync("/me.jpg");
    tex.minFilter = THREE.LinearFilter;
    tex.magFilter = THREE.LinearFilter;
    tex.wrapS = THREE.RepeatWrapping;
    tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(1, 1);

    const uniforms = {
      iChannel0: { value: tex },
      iResolution: { value: new THREE.Vector3(tex.image.width, tex.image.height, 1) },
      iTime: { value: 0 },
      AMT: { value: 0.15 }, // glitch intensity
      SPEED: { value: 0.35 }, // glitch speed
      rectMin: { value: new THREE.Vector2(0.1, 0.4) },
      rectMax: { value: new THREE.Vector2(0.9, 0.7) },
      pixelSize: { value: 11.0 } // pixelation intensity (in pixels)
    };

    const material = new THREE.ShaderMaterial({
      uniforms,
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = vec4(position.xy, 0.0, 1.0);
        }
      `,
      fragmentShader: `
        precision highp float;
        uniform sampler2D iChannel0;
        uniform vec3 iResolution;
        uniform float iTime;
        uniform float AMT;
        uniform float SPEED;
        uniform vec2 rectMin;
        uniform vec2 rectMax;
        uniform float pixelSize;
        varying vec2 vUv;

        float random2d(vec2 n) { 
          return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
        }

        float randomRange (in vec2 seed, in float min, in float max) {
          return min + random2d(seed) * (max - min);
        }

        float insideRange(float v, float bottom, float top) {
          return step(bottom, v) - step(top, v);
        }

        void main() {
          vec2 uv = vUv;

          // Rectangular mask: 1 inside, 0 outside
          float inRect = step(rectMin.x, uv.x) * step(rectMin.y, uv.y) *
                         step(uv.x, rectMax.x) * step(uv.y, rectMax.y);
          vec2 px = iResolution.xy / pixelSize;
          // Pixelate inside rectangle
          float s = smoothstep(0.0, 0.2, abs(uv.y - 0.55));
          if (inRect > 0.5) uv = mix(floor(uv * px + .5)/ px, uv, s);

          // Soft mask (central oval)
          vec2 center = vec2(0.5, 0.5);
          float dist = length((uv - center) / vec2(0.5, 0.3)); // elliptical mask
          float mask = smoothstep(1.0, 0.7, dist); // 1 in center â†’ 0 outside

          float time = floor(iTime * SPEED * 60.0);    
          vec3 outCol = texture2D(iChannel0, uv).rgb;

          float maxOffset = AMT/2.0;
          for (float i = 0.0; i < 10.0 * AMT; i += 1.0) {
            float sliceY = random2d(vec2(time , 2345.0 + float(i)));
            float sliceH = random2d(vec2(time , 9035.0 + float(i))) * 0.25;
            float hOffset = randomRange(vec2(time , 9625.0 + float(i)), -maxOffset, maxOffset);
            vec2 uvOff = uv;
            uvOff.x += hOffset;
            if (insideRange(uv.y, sliceY, fract(sliceY+sliceH)) == 1.0 ){
              outCol = texture2D(iChannel0, uvOff).rgb;
            }
          }

          float maxColOffset = AMT/6.0;
          float rnd = random2d(vec2(time , 9545.0));
          vec2 colOffset = vec2(
            randomRange(vec2(time , 9545.0),-maxColOffset,maxColOffset),
            randomRange(vec2(time , 7205.0),-maxColOffset,maxColOffset)
          ) * mask;

          if (rnd < 0.33){
            outCol.r = texture2D(iChannel0, uv + colOffset).r;
          } else if (rnd < 0.66){
            outCol.g = texture2D(iChannel0, uv + colOffset).g;
          } else {
            outCol.b = texture2D(iChannel0, uv + colOffset).b;  
          }

          gl_FragColor = vec4(outCol,1.0);
        }
      `
    });

    const quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
    scene.add(quad);

    function animate(t) {
      uniforms.iTime.value = t * 0.001;
      renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
  </script>
{{ end }}
